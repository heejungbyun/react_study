<!doctype html>
<html lang="ko">
<head>
<title>Ajax Study</title>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" type="text/css" href="css/theme_atom_one_dark.css">
<link rel="stylesheet" type="text/css" href="css/style.css">
<script src="js/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script> 
</head>
<body>
<div id="jgsWrap" class="jgs_wrap">
    <header>
        <h1><a href="#jgsWrap">Ajax Study</a></h1>
        <nav class="gnb">
            <strong class="screen_out">페이지 메뉴</strong>
            <ul class="list_menu">
                <li>
                    <a href="#cont1">개념정리</a>
                    <ul>
                        <li><a href="#desc1">Ajax란?</a></li>
                        <li><a href="#desc2">Ajax를 구현하는 기술</a></li>
                        <li><a href="#desc3">XMLHttpRequest</a></li>
                    </ul>
                </li>
                <li>
                    <a href="#cont2">웹페이지 구현방식</a>
                    <ul>
                        <li><a href="#cont2">기존의 웹페이지 구현 방식</a></li>
                        <li><a href="#cont3">Ajax를 적용한 구현 방식</a></li>
                    </ul>
                </li>
                <li>
                    <a href="#cont4">jQuery의 Ajax 함수</a>
                    <ul>
                        <li><a href="#desc4">$.ajax() 함수의 사용</a></li>
                        <li><a href="#desc5">콜백함수 처리</a></li>
                        <li><a href="#desc6">에러처리</a></li>
                    </ul>
                </li>
            </ul>
        </nav>
    </header>
    <section id="cont1" class="cont">
        <h2>개념정리</h2>
        <div class="info">
            <div id="desc1" class="info_desc">
                <strong>Ajax란?</strong>
                <p>Ajax는 'Asynchronous Javascript And XML(비동기 Javascript And XML)'의 약자.<br>2005년 2월 Google맵에서 사용한 비동기 통신 기법을 'Ajax'라고 이름붙인 것에서 유래되었음.<br>Ajax를 사용한 페이지에서는 페이지를 새로 고치는 것과는 다른 별도의 비동기적 통신을 수행해서 마우스 등의 조작에 대한 데이터를 서버로부터 추출하여 페이지를 표시함.</p>
                <div class="desc_well">
                    <strong>Ajax를 실제로 어디에 사용하나?</strong>
                    <ul>
                        <li>구글맵 : 마우스를 움직이는 것만으로 페이지가 갱신되지 않고 지도의 축척과 방위가 바뀜</li>
                        <li>인터넷 쇼핑몰 : 사용자가 어떤 상품에 대한 상세내역(ex. 색깔이나 크기 등)을 페이지 갱신없이 선택하여 조작을 빠르게 할수있다.</li>
                    </ul>
                </div>
            </div>
            <div id="desc2" class="info_desc">
                <strong>Ajax를 구현하는 기술</strong>
                <p>웹페이지를 HTML과 CSS를 사용한 웹 표준 기술로 작성.<br>Javascript를 기반으로 데이터 활용 및 변환과 조작<br>XMLHttpRequest 라는 오브젝트를 사용하여 비동기적으로 데이터(XML,JSON...)를 송·수신함.</p>
            </div>
            <div id="desc3" class="info_desc">
                <strong>XMLHttpRequest</strong>
                <p>XMLHttpRequest 객체는 서버측 Javascript와 통신하기 위한 Ajax의 핵심 기술이며, Ajax의 가장 강력한 특징인 <span class="txt_strong">비동기성</span>을 가능케 한다. 그리고 비동기처리로 인해 페이지는 사용자 이벤트를 처리하면서 전체 페이지가 아닌 일부분만을 업데이트 할 수 있게 된다.</p>
            </div>
        </div>
    </section><!--// .cont -->
    <section id="cont2" class="cont">
        <h2>기존의 웹페이지 구현 방식</h2>
        <div class="info">
            <div class="info_desc">
                <strong>필수적인 Page Redirect 처리</strong>
                <p>고전적인 웹 페이지 개발 방식의 문제는, 사용자에게 새로운 내용을 보여주기 위해 반드시 페이지의 이동이나 새로고침이 발생함.</p>
                <figure>
                    <figcaption>게시판 글 작성 후 읽기 페이지로 이동하는 과정<br>사용자 입장에서는 글저장시 읽기 페이지로 화면이동이 발생하는 것처럼 보이게됨</figcaption>
                    <img src="images/vs_redirect.gif" alt="고전적인 웹페이지에서 게시판 글 작성시 과정">
                    <figcaption class="screen_out">1.사용자가 내용 입력후 등록하면 웹브라우저 자체가 서버에 데이터 전달. 2.서버에서 요청받은 데이터를 처리후 HTML생성. 3.처리된 데이터 브라우저로 HTML 전송</figcaption>
                </figure>
                <p>웹페이지의 동작에는 반드시 "요청"과 "응답"의 관계가 성립 되어야 하는데, 기존의 웹페이지 제작방식의 요청과 응답 과정에서는 페이지 Redirect처리가 필수 불가결이였고, 사용자 입장에서는 모든 처리마다 페이지 이동이 발생하는 것처럼 느껴질 수 밖에 없었다.<br>이러한 처리는 아주 약간의 변경사항을 보여주기 위해서라도 전체 HTML코드를 재전송 해야하는 비효율적인 측면이 있다. 그 과정에서 과도한 트래픽을 발생시키게 되고, 서버의 유지비용이 더 크게 발생하게 된다.</p>
            </div>
            <div class="info_desc">
                <strong>고전적인 웹사이트 제작 방식</strong>
                <p>또 다른 문제는 작업의 비 효율성이다. 웹페이지에서 UI를 구성한 퍼블리싱의 결과물에 웹프로그래머가 재작업하여 웹프로그램을 추가하는 기존 방식에서는 웹프로그래머가 퍼블리싱의 결과물이 있어야 작업을 진행 할 수 있기에 기간이 오래 걸리고, 서로간의 결과물이 뒤섞여 유지보수가 어렵게 된다.</p>
                <table>
                    <caption>기존 작업방식에 따른 포지션별 역할</caption>
                    <colgroup>
                        <col width="50%">
                        <col width="50%">
                    </colgroup>
                    <thead>
                        <tr>
                        <th scope="col">웹퍼블리셔</th>
                        <th scope="col">웹프로그래머</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                        <td>
                            <em class="tit_block">HTML / CSS / Javscript 코딩</em>
                            Photoshop으로 제작되어 잘라진 이미지에 HTML과 CSS를 사용하여 화면을 구성한다.<br>Javascript를 추가하여 반응을 구현한다.
                        </td>
                        <td>
                            <em class="tit_block">동적인 페이지 구현</em>
                            사용자의 선택이나 입력한 내용에 따라 페이지의 내용이 동적으로 다르게 생성되어 표시되도록 퍼블리싱의 결과물을 재작업한다.
                            <em class="tit_block">데이터 제어</em>
                            DATABASE 시스템과 웹페이지를 연계하는 중간 과정의 처리를 통하여 입력값을 저장하거나, 저장된 내용을 화면에 표시하기 위한 HTML을 재구성한다.
                        </td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>
    </section><!-- // .cont -->
    <section id="cont3" class="cont">
        <h2>Ajax를 적용한 구현 방식</h2>
        <div class="info">
            <div class="info_desc">
                <strong>Ajax 방식의 데이터 처리</strong>
                <p>Ajax가 적용된 페이지는 전체 HTML이 아닌, XML이나 JSON형식으로 구성된 새로운 내용(데이터)만을 XMLHttpRequest객체를 통해 받아오기 때문에, 페이지 이동없이 새로운 내용을 사용자에게 제공할 수 있다.</p>
                 <figure>
                    <img src="images/vs_ajax.gif" alt="Ajax 환경에서의 사용자 글작성 전송 과정">
                </figure>
            </div>
            <div class="info_desc">
                <strong>Ajax를 도입한 웹페이지 제작 방식</strong>
                <p>Ajax는 웹페이지에 보여져야 할 내용(데이터)을 웹프로그램에서 생성하고, 그 데이터를 Javascript를 통해 페이지 이동 없이 화면에 출력하는 기술이다. Javascript를 웹퍼블리싱 파트에서 작업한다고 가정했을때, 이러한 Ajax의 특성을 통해 웹프로그래머와 퍼블리셔의 작업 영역이 완전히 분리되면 더욱 효율적인 작업이 가능하다.</p>
                <table>
                    <caption>Ajax 작업방식에 따른 포지션별 역할</caption>
                    <colgroup>
                        <col width="50%">
                        <col width="50%">
                    </colgroup>
                    <thead>
                        <tr>
                        <th scope="col">웹퍼블리셔</th>
                        <th scope="col">웹프로그래머</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                        <td>
                            HTML과 CSS를 사용한 웹페이지의 UI를 구성한다.<br>Ajax를 사용하여 사용자가 입력한 내용을 웹서버에 전달(또는 요청)하고, 그에 따른 결과를 화면에 출력하기 위해 DOM을 컨트롤한다.
                        </td>
                        <td>
                            웹페이지의 요청에 따른 데이터를 XML이나 JSON으로 구성하여 Javascript에 전달한다.<br>데이터를 구성하는 과정에서 데이터베이스를 통한 입력 / 수정 / 삭제 / 조회 등의 작업이 처리될 수 있다.
                        </td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>
    </section>
    <section id="cont4" class="cont">
        <h2>jQuery의 Ajax 함수</h2>
        <div class="info">
            <div class="info_desc">
                <strong>Classic Javascript의 Ajax와 jQuery의 Ajax 비교</strong>
                <p>Classic Javascript를 사용하여 직접 Ajax를 구현할 경우 XMLHttpRequest 내장객체를 사용하게 된다. 하지만 IE는 XMLHttpRequest 객체를 지원하지 않고, MSXML객체를 사용해야 한다. 두 객체 안에 포함된 함수는 동일하지만 IE와 그 이외의 브라우저를 구별하여 내장객체에 접근해야 하므로, 서로 다른 코드를 구현해야 한다는 부담감이 있다.</p>
            </div>
            <div id="desc4" class="info_desc">
                <strong>jQuery의 $.ajax() 함수의 사용</strong>
                <p>jQuery는 $.ajax() 함수를 사용하여 자체적으로 크로스브라우징을 구현하고 있기 때문에, 개발과정에서 브라우저 종류를 고민 할 필요 없이 한번의 처리로 모든 브라우저를 지원할 수 있다. 또한, $.ajax() 함수에서 파생된 load(), $.get(), $.post(), $.getJSON() 등을 통해 상황에 따라 사용할 수 있도록 여러 함수들을 제공한다.</p>
            </div>
            <div class="info_desc">
                <strong>기본 사용법</strong>
                <p>$.ajax() 함수에 웹서버로 보내기 위한 요청 설정 정보와, 통신이 성공했을 경우에 실행 될 함수, 통신에 실패했을 경우 실행 될 함수를 설정한다.</p>
                <pre class="code">
                <code class="javascript">
                    $.ajax({
                        url : "",             // 접속할 페이지 주소
                        type : "",            // get/post
                        data : "",            // 파라미터 문자열 key=value&key=value
                        dataType : "",        // text/xml/json/jsonp
                        timeout :   ,        // 밀리세컨드단위 제한시간
                        cache :   ,           // 캐쉬 사용여부 true/false (GET 방식일경우 true가 default)
                        success : function(data){
                            // 통신이 성공했을 때 실행 함수
                            $("div").html(data);
                        },
                        error : function(xhr, textStatus, errorThrown){
                            // 통신이 실패했을 때 실행 함수
                            $("div").html(textStatus + " (HTTP-" + xhr.status + " / " + errorThrown + ")");
                        }
                    });
                </code></pre>
            </div>
            <div id="desc5" class="info_desc">
                <strong>콜백함수의 처리</strong>
                <p>$.ajax() 함수는 웹서버와 통신 결과에 따라 success()함수나 error()함수를 선택적으로 호출하게 된다. 이 함수들은 $.ajax()의 파라미터로 구성된 JSON 데이터 안에 포함되어 있으며, 통신이 성공하여 데이터를 가져오는 것이 가능하게 되면, success()함수 안에서 가져온 데이터를 가공하여 화면에 표시되도록 처리한다. error()함수는 어떠한 이유로 인하여 통신에 실패한 경우에 대한 처리를 구현하기 위한 콜백함수이다.</p>
                <table>
                    <caption>통신결과에 따른 실행함수</caption>
                    <colgroup>
                        <col width="50%">
                        <col width="50%">
                    </colgroup>
                    <thead>
                        <tr>
                        <th scope="col">sucess</th>
                        <th scope="col">error</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                        <td>
                            웹서버에서 전달하는 결과값을 정상적으로 읽어왔을 경우 실행된다.<br>이 함수의 파라미터로 서버에서 읽은 결과가 전달되며, dataType에 "text, xml, json, jsonp"중 어떤 값을 지정하였는지에 따라서 처리 방법이 달라지게 된다.
                        </td>
                        <td>
                            웹서버로부터 응답을 정상적으로 읽어들이지 못한경우에 실행된다.<br>이 콜백에는 세개의 파라미터가 전달되는데, 각 파라미터에 에러의 종류를 의미하는 값이 담겨있다.<br>단, cross-domain 스크립트나 JSONP 요청에 대해서는 이 함수를 사용할 수 없다.
                        </td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div id="desc6" class="info_desc">
                <strong>에러처리</strong>
                <p>error()함수에 전달되는 파라미터를 통해서 에러의 원인을 어느정도 파악할 수 있다. 이 원인을 알 수 있게 해 주는 값을 HTTP ERROR CODE라고 하는데, 이 값에는 크게 404에러와 500에러가 있다. 그 외에 errorThrown 이라는 값은 에러의 원인을 의미하는 문자열인데 자세한 에러의 원인이라기 보다는 간결한 문장만 전달되므로 에러 상태를 파악하기 위한 부분은 많은 Ajax 처리 경험을 통해서 쌓아야 한다.</p>
                <table>
                    <caption>error()콜백함수에 전달되는 파라미터</caption>
                    <colgroup>
                        <col width="20%">
                        <col width="80%">
                    </colgroup>
                    <thead>
                        <tr>
                        <th scope="col">파라미터</th>
                        <th scope="col">설명</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                        <th scope="row">xhr</th>
                        <td>
                            Javascript에서 Ajax 처리를 위해서 사용되는 XMLHttpRequest 객체의 원본.<br>이 객체가 포함하는 satus 속성에 HTTP ERROR CODE 값이 포함된다.<br>
                            <em class="tit_block">HTTP ERROR CODE</em>
                            404 (Page Not Found) - URL이 잘못 명시되었거나 네트워크 오류, 웹서버의 동작 중지 등으로 접속이 불가능한 상태.<br>
                            500 (Server Error) - 웹프로그램의 오류. 이 경우, 해당 페이지를 작업한 웹프로그램 파트에서 문제를 수정해야함.
                        </td>
                        </tr>
                        <tr>
                        <th>
                            textStatus
                        </th>
                        <td>
                            상황에 따른 "timeout", "error", "abort", "parsererror" 와 같은 메세지를 전달함.
                        </td>
                        </tr>
                        <tr>
                        <th>
                            errorThrown
                        </th>
                        <td>
                            에러의 원인을 의미하는 문자열이 전달됨.<br>404 에러일 경우 "Page Not Found"라고 전달되고, 500 에러 일 경우 "Server Error"라는 문자열이 전달된다. 웹서버에서 표시하는 웹프로그램에 대한 에러 메시지는 알지 못하므로, 웹프로그래머는 이 값을 에러 추적에 사용할 수는 없다.
                        </td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="info_desc">
                <strong>Global Ajax event handlers</strong>
                <p>아래 메서드들은 전역으로 설정가능한 ajax 이벤트 핸들러로 jQuery 1.9.x 버전부터 document에만 할당 할 수 있도록 수정되었다. 핸들러를 할당하고 난 뒤에는 문서에서 발생한 모든 Ajax 이벤트에 반응한다.</p>
                <table>
                    <caption>Event handlers</caption>
                    <colgroup>
                        <col width="20%">
                        <col width="80%">
                    </colgroup>
                    <thead>
                        <tr>
                        <th scope="col">handlers</th>
                        <th scope="col">설명</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                        <th scope="row">.ajaxStart( callback )</th>
                        <td>
                            Ajax request의 송신 전 active request가 없는 경우에 실행되는 함수를 지정한다.
                        </td>
                        </tr>
                        <tr>
                        <th scope="row">.ajaxSend( callback )</th>
                        <td>
                            Ajax request의 송신 전 실행되는 함수를 지정한다.
                        </td>
                        </tr>
                        <tr>
                        <th scope="row">.ajaxSuccess( callback )</th>
                        <td>
                            Ajax request의 송신 성공 시 실행되는 함수를 지정한다.
                        </td>
                        </tr>
                        <tr>
                        <th scope="row">.ajaxError( callback )</th>
                        <td>
                            Ajax request의 송신 실패 시 실행되는 함수를 지정한다.
                        </td>
                        </tr>
                        <tr>
                        <th scope="row">.ajaxComplete( callback )</th>
                        <td>
                            Ajax request의 송신 완료 시 실행되는 함수를 지정한다.
                        </td>
                        </tr>
                        <tr>
                        <th scope="row">.ajaxStop( callback )</th>
                        <td>
                            Ajax request의 송신 종료 시 실행되는 함수를 지정한다.
                        </td>
                        </tr>
                    </tbody>
                </table>
                <pre class="code"><code class="javascript">
                    $(document).ajaxStart(function() {
                        console.log('ajax started');
                    }).ajaxComplete(function(){
                        console.log('ajax complete');
                    });
                </code></pre>
            </div>
            <div class="info_desc">
                <strong>load() 함수</strong>
                <em class="txt_line">TEXT나 다른 HTML을 읽어오기 위한 코드 축약</em>
                <p>읽어오고자 하는 대상의 내용이 단순한 text나 html 태그를 표현하며 읽어온 내용을 특정 요소에 출력하는것만을 목적으로 할 경우 load() 함수를 사용해 코드를 축약할 수 있다.</p>
                <pre class="code">
                <code class="javascript">
                    $("[CSS selector]").load("URL", function(){
                        // 읽기에 성공한 후 실행될 함수
                    });
                </code> </pre>
                <p>load() 함수는 TEXT파일이나 HTML 파일의 전체 내용을 읽어와 특정 요소 안에 출력하는 것을 기본 기능으로 하지만, 어떠한 HTML 페이지의 특정 요소에 대한 내용만을 읽어오는 것도 가능한데, 특정 id 값을 선별 단위 기준으로 한다.</p>
                <pre class="code">
                <code class="javascript">
                    $("[출력할 대상의 셀렉터]").load("example.html #content1");
                    // example.html파일에 구성된 id="content1" 엘리먼트를 출력함
                </code></pre>
            </div>
        </div>
    </section>
</div>

</body>
</html>